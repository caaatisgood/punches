type GoalId = nat;

type Goal = {
  id: GoalId,
  goal: string,
  tokens: list<nat>,
  active: bool,
};

type TokenData = big_map<nat, {
  goal_id: nat,
  note: string,
  mood: int, // default: -1, 1 ~ 10
}>;

type Storage = {
  token_count: nat,
  tickets: big_map<nat, ticket<nat>>,
  goals: big_map<address, map<GoalId, Goal>>,
  goal_chars: nat, // prob ~100
  note_chars: nat, // prob ~50
  admin: address,
};

type Parameter =
  // permissionless
  | ["Set_Goal", string]
  | ["Update_Goal", { goal: string, id: GoalId }]
  | ["Punch", { note: string, id: GoalId }]
  | ["Activate_Goal", GoalId]
  | ["Deactivate_Goal", GoalId]
  // admin
  | ["Update_Goal_Chars", nat]
  | ["Update_Note_Chars", nat];

type Return = [list<operation>, Storage];

const setGoal = (
  { token_count, tickets, goals, admin, goal_chars, note_chars }: Storage,
  goal: string
): Storage => {
  const sender = Tezos.get_sender();
  const goalMap: map<GoalId, Goal> = match((Big_map.find_opt(sender, goals)), {
    Some: (goalMap: map<GoalId, Goal>) => goalMap,
    None: () => (Map.empty as map<GoalId, Goal>),
  });
  if (String.length(goal) > goal_chars) {
    failwith("GOAL_EXCEEDS_MAX_LEN");
  }
  const id: nat = Map.size(goalMap);
  const newGoal: Goal = {
    id,
    goal,
    tokens: (list([]) as list<nat>),
    active: true,
  };
  const updatedGoalMap = Map.add(id, newGoal, goalMap);
  const updatedGoals = Big_map.update(
    sender,
    Some(updatedGoalMap),
    goals
  );
  return { token_count, tickets, goals: updatedGoals, admin, goal_chars, note_chars };
};

const updateGoal = (
  { token_count, tickets, goals, admin, goal_chars, note_chars }: Storage,
  { goal, id }: { goal: string, id: nat }
): Storage => {
  const sender = Tezos.get_sender();
  const goalMap: map<GoalId, Goal> = match((Big_map.find_opt(sender, goals)), {
    Some: (goalMap: map<GoalId, Goal>) => goalMap,
    None: () => failwith("NOT_FOUND"),
  });
  const goalObj: Goal = match((Map.find_opt(id, goalMap)), {
    Some: (goalObj: Goal) => goalObj,
    None: () => failwith("NOT_FOUND"),
  });
  if (String.length(goal) > goal_chars) {
    failwith("GOAL_EXCEEDS_MAX_LEN");
  }
  const updatedGoalMap = Map.update(id, Some({ ...goalObj, goal }), goalMap);
  const updatedGoals = Big_map.update(sender, Some(updatedGoalMap), goals);
  return { token_count, tickets, goals: updatedGoals, admin, goal_chars, note_chars };
};

const punch = (
  { token_count, tickets, goals, admin, goal_chars, note_chars }: Storage,
  { note, id }: { note: string, id: GoalId }
): Storage => {
  const sender = Tezos.get_sender();
  const goalMap: map<GoalId, Goal> = match((Big_map.find_opt(sender, goals)), {
    Some: (goalMap: map<GoalId, Goal>) => goalMap,
    None: () => failwith("NOT_FOUND"),
  });
  const goalObj: Goal = match((Map.find_opt(id, goalMap)), {
    Some: (goalObj: Goal) => goalObj,
    None: () => failwith("NOT_FOUND"),
  });
  if (String.length(note) > note_chars) {
    failwith("NOTE_EXCEEDS_MAX_LEN");
  }
  const ticketId: nat = token_count + (1 as nat);
  const ticket_: ticket<nat> = Option.unopt(Tezos.create_ticket(ticketId, 1 as nat));
  const [_, updatedTickets] = Big_map.get_and_update(ticketId, Some(ticket_), tickets);
  const updatedGoalMap = Map.update( id,
    Some({
      ...goalObj,
      tokens: list([ticketId, ...goalObj.tokens]),
    }),
    goalMap
  );
  const updatedGoals = Big_map.update(sender, Some(updatedGoalMap), goals);
  return {
    token_count: ticketId,
    tickets: updatedTickets,
    goals: updatedGoals,
    admin,
    goal_chars,
    note_chars,
  };
};

const activateGoal = (
  { token_count, tickets, goals, admin, goal_chars, note_chars }: Storage,
  id: GoalId
): Storage => {
  const sender = Tezos.get_sender();
  const goalMap: map<GoalId, Goal> = match((Big_map.find_opt(sender, goals)), {
    Some: (goalMap: map<GoalId, Goal>) => goalMap,
    None: () => failwith("NOT_FOUND"),
  });
  const goalObj: Goal = match((Map.find_opt(id, goalMap)), {
    Some: (goalObj: Goal) => goalObj,
    None: () => failwith("NOT_FOUND"),
  });
  if (goalObj.active) {
    return { token_count, tickets, goals, admin, goal_chars, note_chars };
  };
  const updatedGoalMap = Map.update(id, Some({ ...goalObj, active: true }), goalMap);
  const updatedGoals = Big_map.update(sender, Some(updatedGoalMap), goals);
  return { token_count, tickets, goals: updatedGoals, admin, goal_chars, note_chars };
};

const deactivateGoal = (
  { token_count, tickets, goals, admin, goal_chars, note_chars }: Storage,
  id: GoalId
): Storage => {
  const sender = Tezos.get_sender();
  const goalMap: map<GoalId, Goal> = match((Big_map.find_opt(sender, goals)), {
    Some: (goalMap: map<GoalId, Goal>) => goalMap,
    None: () => failwith("NOT_FOUND"),
  });
  const goalObj: Goal = match((Map.find_opt(id, goalMap)), {
    Some: (goalObj: Goal) => goalObj,
    None: () => failwith("NOT_FOUND"),
  });
  if (!goalObj.active) {
    return { token_count, tickets, goals, admin, goal_chars, note_chars };
  };
  const updatedGoalMap = Map.update(id, Some({ ...goalObj, active: false }), goalMap);
  const updatedGoals = Big_map.update(sender, Some(updatedGoalMap), goals);
  return { token_count, tickets, goals: updatedGoals, admin, goal_chars, note_chars };
};

const updateGoalChars = (
  { token_count, tickets, goals, admin, goal_chars, note_chars }: Storage,
  chars: nat
): Storage => {
  const sender = Tezos.get_sender();
  if (sender != admin) {
    failwith("INSUFFICIENT_PERMISSION");
  }
  return { token_count, tickets, goals, admin, goal_chars: chars, note_chars };
};

const updateNoteChars = (
  { token_count, tickets, goals, admin, goal_chars, note_chars }: Storage,
  chars: nat
): Storage => {
  const sender = Tezos.get_sender();
  if (sender != admin) {
    failwith("INSUFFICIENT_PERMISSION");
  }
  return { token_count, tickets, goals, admin, goal_chars, note_chars: chars };
};

const main = (parameter: Parameter, store: Storage): Return => {
  return [
    list([]),
    (match (parameter, {
      Set_Goal: (goal: string) => setGoal(store, goal),
      Update_Goal: (params) => updateGoal(store, params),
      Punch: (params) => punch(store, params),
      Activate_Goal: (goal_id: GoalId) => activateGoal(store, goal_id),
      Deactivate_Goal: (goal_id: GoalId) => deactivateGoal(store, goal_id),
      Update_Goal_Chars: (chars: nat) => updateGoalChars(store, chars),
      Update_Note_Chars: (chars: nat) => updateNoteChars(store, chars),
    }))
  ];
};
